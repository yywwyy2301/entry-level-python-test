import abc
import datetime
import enum
import json
import pickle
import uuid
from collections import defaultdict, deque
from multiprocessing import shared_memory
from typing import Self

from PyQuantKit import MarketData

from . import LOGGER

__all__ = ['MDS', 'MarketDataService', 'MarketDataMonitor', 'MonitorManager', 'Profile']
LOGGER = LOGGER.getChild('MarketEngine')


class MarketDataMonitor(object, metaclass=abc.ABCMeta):
    """
    this is a template for market data monitor

    A data monitor is a module that process market data and generate custom index

    When MDS receive an update of market data, the __call__ function of this monitor is triggered.

    Note: all the market_data, of all subscribed ticker will be fed into monitor. It should be assumed that a storage for multiple ticker is required.
    To access the monitor, use `monitor = MDS[monitor_id]`
    To access the index generated by the monitor, use `monitor.value`
    To indicate that the monitor is ready to use set `monitor.is_ready = True`

    The implemented monitor should be initialized and use `MDS.add_monitor(monitor)` to attach onto the engine
    """

    def __init__(self, name: str, monitor_id: str = None):
        self.name: str = name
        self.monitor_id: str = uuid.uuid4().hex if monitor_id is None else monitor_id
        self.enabled: bool = True

    @abc.abstractmethod
    def __call__(self, market_data: MarketData, **kwargs):
        ...

    def __reduce__(self):
        return self.__class__.from_json, (self.to_json(),)

    @abc.abstractmethod
    def to_json(self, fmt='str') -> dict | str:
        ...

    @classmethod
    @abc.abstractmethod
    def from_json(cls, json_message: str | bytes | bytearray | dict) -> Self:
        ...

    def to_shm(self, name: str = None) -> str:
        """
        Put the data of the monitor into python shared memory.
        This function is designed to facilitate multiprocessing.
        Some monitor is not advised to be handled concurrently,
        In which case, raise a NotImplementedError.

        The function is expected to put all data into a sharable list,
        and return the name of the list, which can be set by the given name.
        Default name = self.monitor_id

        Note that this method HAVE NO LOCK, use with caution.
        """
        if name is None:
            name = f'{self.monitor_id}.json'

        data = pickle.dumps(self.to_json(fmt='dict'))
        size = len(data)

        try:
            shm = shared_memory.SharedMemory(name=name)

            if shm.size != size:
                shm.close()
                shm.unlink()
                shm = shared_memory.SharedMemory(create=True, size=size, name=name)
        except FileNotFoundError as _:
            shm = shared_memory.SharedMemory(create=True, size=size, name=name)

        shm.buf[:size] = data
        shm.close()
        return name

    def from_shm(self, name: str = None) -> None:
        """
        retrieve the data and update the monitor from shared memory.
        This function is designed to facilitate multiprocessing.
        """
        return

    @abc.abstractmethod
    def clear(self) -> None:
        ...

    @property
    @abc.abstractmethod
    def value(self) -> dict[str, float] | float:
        ...

    @property
    def is_ready(self) -> bool:
        return True


class MonitorManager(object):
    """
    manage market data monitor

    state codes for the manager
    0: idle
    1: working
    -1: terminating
    """

    def __init__(self):
        self.monitor: dict[str, MarketDataMonitor] = {}

    def __call__(self, market_data: MarketData):
        for monitor_id in self.monitor:
            self._work(monitor_id=monitor_id, market_data=market_data)

    def add_monitor(self, monitor: MarketDataMonitor):
        self.monitor[monitor.monitor_id] = monitor

    def pop_monitor(self, monitor_id: str) -> MarketDataMonitor:
        return self.monitor.pop(monitor_id)

    def _work(self, monitor_id: str, market_data: MarketData):
        monitor = self.monitor.get(monitor_id)
        if monitor is not None and monitor.enabled:
            monitor.__call__(market_data)

    def clear(self):
        self.monitor.clear()


class Profile(object, metaclass=abc.ABCMeta):
    def __init__(
            self,
            session_start: datetime.time | None = None,
            session_end: datetime.time | None = None,
            session_break: tuple[datetime.time, datetime.time] | None = None
    ):
        self.session_start: datetime.time | None = session_start
        self.session_end: datetime.time | None = session_end
        self.session_break: tuple[datetime.time, datetime.time] | None = session_break

    @abc.abstractmethod
    def trade_time_between(self, start_time: datetime.datetime | float, end_time: datetime.datetime | float, **kwargs) -> datetime.timedelta:
        ...

    @abc.abstractmethod
    def in_trade_session(self, market_time: datetime.datetime | float) -> bool:
        ...


class DefaultProfile(Profile):
    def __init__(self):
        super().__init__(
            session_start=datetime.time(0),
            session_end=None,
            session_break=None
        )

    def trade_time_between(self, start_time: datetime.datetime | float, end_time: datetime.datetime | float, **kwargs) -> datetime.timedelta:
        if start_time is not None and isinstance(start_time, (float, int)):
            start_time = datetime.datetime.fromtimestamp(start_time)

        if end_time is not None and isinstance(end_time, (float, int)):
            end_time = datetime.datetime.fromtimestamp(end_time)

        if start_time is None or end_time is None:
            return datetime.timedelta(seconds=0)

        if start_time > end_time:
            return datetime.timedelta(seconds=0)

        return end_time - start_time

    def in_trade_session(self, market_time: datetime.datetime | float) -> bool:
        return True


class MarketDataService(object):
    def __init__(self, profile: Profile = None, **kwargs):
        self.profile = DefaultProfile() if profile is None else profile
        self.synthetic_orderbook = kwargs.pop('synthetic_orderbook', False)
        self.cache_history = kwargs.pop('cache_history', False)

        self._market_price = {}
        self._market_history = defaultdict(dict)
        self._market_time: datetime.datetime | None = None
        self._timestamp: float | None = None

        self._monitor: dict[str, MarketDataMonitor] = {}
        self._monitor_manager = MonitorManager()

    def __call__(self, **kwargs):
        if 'market_data' in kwargs:
            self.on_market_data(market_data=kwargs['market_data'])

    def __getitem__(self, monitor_id: str) -> MarketDataMonitor:
        return self.monitor[monitor_id]

    def add_monitor(self, monitor: MarketDataMonitor):
        self.monitor[monitor.monitor_id] = monitor
        self.monitor_manager.add_monitor(monitor)

    def pop_monitor(self, monitor: MarketDataMonitor = None, monitor_id: str = None, monitor_name: str = None):
        if monitor_id is not None:
            pass
        elif monitor_name is not None:
            for _ in list(self.monitor.values()):
                if _.name == monitor_name:
                    monitor_id = _.monitor_id
            if monitor is None:
                LOGGER.error(f'monitor_name {monitor_name} not registered.')
        elif monitor is not None:
            monitor_id = monitor.monitor_id
        else:
            LOGGER.error('must assign a monitor, or monitor_id, or monitor_name to pop.')
            return None

        self.monitor.pop(monitor_id)
        self.monitor_manager.pop_monitor(monitor_id)

    def on_market_data(self, market_data: MarketData):
        ticker = market_data.ticker
        market_time = market_data.market_time
        timestamp = market_data.timestamp
        market_price = market_data.market_price

        self._market_price[ticker] = market_price
        self._market_time = market_time
        self._timestamp = timestamp

        if self.cache_history:
            self._market_history[ticker][market_time] = market_price

        self.monitor_manager.__call__(market_data=market_data)

    def trade_time_between(self, start_time: datetime.datetime | float, end_time: datetime.datetime | float, **kwargs) -> datetime.timedelta:
        return self.profile.trade_time_between(start_time=start_time, end_time=end_time, **kwargs)

    def in_trade_session(self, market_time: datetime.datetime | float) -> bool:
        return self.profile.in_trade_session(market_time=market_time)

    def clear(self):
        # self._market_price.clear()
        # self._market_time = None
        # self._timestamp = None

        self._market_history.clear()
        self.monitor.clear()
        self.monitor_manager.clear()

    @property
    def market_price(self) -> dict[str, float]:
        result = self._market_price
        return result

    @property
    def market_history(self) -> dict[str, dict[datetime.datetime, float]]:
        result = self._market_history
        return result

    @property
    def market_time(self) -> datetime.datetime | None:
        if self._market_time is None:
            if self._timestamp is None:
                return None
            else:
                return datetime.datetime.fromtimestamp(self._timestamp)
        else:
            return self._market_time

    @property
    def market_date(self) -> datetime.date | None:
        if self.market_time is None:
            return None

        return self._market_time.date()

    @property
    def timestamp(self) -> float | None:
        if self._timestamp is None:
            if self._market_time is None:
                return None
            else:
                return self._market_time.timestamp()
        else:
            return self._timestamp

    @property
    def session_start(self) -> datetime.time | None:
        return self.profile.session_start

    @property
    def session_end(self) -> datetime.time | None:
        return self.profile.session_end

    @property
    def session_break(self) -> tuple[datetime.time, datetime.time] | None:
        return self.profile.session_break

    @property
    def monitor(self) -> dict[str, MarketDataMonitor]:
        return self._monitor

    @property
    def monitor_manager(self) -> MonitorManager:
        return self._monitor_manager

    @monitor_manager.setter
    def monitor_manager(self, manager: MonitorManager):
        self._monitor_manager.clear()

        self._monitor_manager = manager

        for monitor in self.monitor.values():
            self._monitor_manager.add_monitor(monitor=monitor)


MDS = MarketDataService()


class SamplerMode(enum.Enum):
    update = 'update'
    accumulate = 'accumulate'


class FixedIntervalSampler(object, metaclass=abc.ABCMeta):
    """
    Abstract base class for a fixed interval sampler designed for financial usage.

    Args:
    - sampling_interval (float): Time interval between consecutive samples. Default is 1.
    - sample_size (int): Number of samples to be stored. Default is 60.

    Attributes:
    - sampling_interval (float): Time interval between consecutive samples.
    - sample_size (int): Number of samples to be stored.

    Warnings:
    - If `sampling_interval` is not positive, a warning is issued.
    - If `sample_size` is less than 2, a warning is issued according to Shannon's Theorem.

    Methods:
    - log_obs(ticker: str, value: float, timestamp: float, storage: Dict[str, Dict[float, float]])
        Logs an observation for the given ticker at the specified timestamp.

    - on_entry_added(ticker: str, key, value)
        Callback method triggered when a new entry is added.

    - on_entry_updated(ticker: str, key, value)
        Callback method triggered when an existing entry is updated.

    - on_entry_removed(ticker: str, key, value)
        Callback method triggered when an entry is removed.

    - clear()
        Clears all stored data.

    Notes:
    - Subclasses must implement the abstract methods: on_entry_added, on_entry_updated, on_entry_removed.

    """

    def __init__(self, sampling_interval: float = 1., sample_size: int = 60):
        """
        Initialize the FixedIntervalSampler.

        Parameters:
        - sampling_interval (float): Time interval between consecutive samples (in seconds). Default is 1.
        - sample_size (int): Number of samples to be stored. Default is 60.
        """
        self.sampling_interval = sampling_interval
        self.sample_size = sample_size

        self.sample_storage = getattr(self, 'sample_storage', {})  # to avoid de-reference the dict using nested inheritance

        # Warning for sampling_interval
        if sampling_interval <= 0:
            LOGGER.warning(f'{self.__class__.__name__} should have a positive sampling_interval')

        # Warning for sample_interval by Shannon's Theorem
        if sample_size <= 2:
            LOGGER.warning(f"{self.__class__.__name__} should have a larger sample_size, by Shannon's Theorem, sample_size should be greater than 2")

    def register_sampler(self, name: str, mode: str | SamplerMode = 'update') -> dict:
        if name in self.sample_storage:
            LOGGER.warning(f'name {name} already registered in {self.__class__.__name__}!')
            return self.sample_storage[name]

        if isinstance(mode, SamplerMode):
            mode = mode.value

        if mode not in ['update', 'accumulate']:
            raise NotImplementedError(f'Invalid mode {mode}, expect "update" or "accumulate".')

        sample_storage = self.sample_storage[name] = dict(
            storage={},
            index={},
            mode=mode
        )

        return sample_storage

    def get_sampler(self, name: str) -> dict[str, deque]:
        if name not in self.sample_storage:
            raise ValueError(f'name {name} not found in {self.__class__.__name__}!')

        return self.sample_storage[name]['storage']

    def log_obs(self, ticker: str, timestamp: float, observation: dict[str, ...] = None, auto_register: bool = True, **kwargs):
        observation_copy = {}

        if observation is not None:
            observation_copy.update(observation)

        observation_copy.update(kwargs)

        idx = timestamp // self.sampling_interval

        for obs_name, obs_value in observation_copy.items():
            if obs_name not in self.sample_storage:
                raise ValueError(f'Invalid observation name {obs_name}')

            sampler = self.sample_storage[obs_name]
            storage: dict[str, deque] = sampler['storage']
            indices: dict = sampler['index']
            mode = sampler['mode']

            if ticker in storage:
                obs_storage = storage[ticker]
            elif auto_register:
                obs_storage = storage[ticker] = deque(maxlen=self.sample_size)
            else:
                LOGGER.warning(f'Ticker {ticker} not registered in sampler {obs_name}, perhaps the subscription has changed?')
                continue

            last_idx = indices.get(ticker, 0)

            if idx > last_idx:
                obs_storage.append(obs_value)
                indices[ticker] = idx
                self.on_entry_added(ticker=ticker, name=obs_name, value=obs_value)
            else:
                if mode == 'update':
                    last_obs = obs_storage[-1] = obs_value
                elif mode == 'accumulate':
                    last_obs = obs_storage[-1] = obs_value + obs_storage[-1]
                else:
                    raise NotImplementedError(f'Invalid mode {mode}, expect "update" or "accumulate".')

                self.on_entry_updated(ticker=ticker, name=obs_name, value=last_obs)

    def on_entry_added(self, ticker: str, name: str, value):
        """
        Callback method triggered when a new entry is added.

        Parameters:
        - ticker (str): Ticker symbol for the added entry.
        - key: Key for the added entry.
        - value: Value of the added entry.
        """
        pass

    def on_entry_updated(self, ticker: str, name: str, value):
        """
        Callback method triggered when an existing entry is updated.

        Parameters:
        - ticker (str): Ticker symbol for the updated entry.
        - key: Key for the updated entry.
        - value: Updated value of the entry.
        """
        pass

    def to_json(self, fmt='str', **kwargs) -> str | dict:
        data_dict = dict(
            sampling_interval=self.sampling_interval,
            sample_size=self.sample_size,
            sample_storage={name: dict(storage={ticker: list(dq) for ticker, dq in value['storage'].items()},
                                       index=value['index'],
                                       mode=value['mode'])
                            for name, value in self.sample_storage.items()}
        )

        if fmt == 'dict':
            return data_dict
        elif fmt == 'str':
            return json.dumps(data_dict, **kwargs)
        else:
            raise ValueError(f'Invalid format {fmt}, except "dict" or "str".')

    @classmethod
    def from_json(cls, json_message: str | bytes | bytearray | dict) -> Self:
        if isinstance(json_message, dict):
            json_dict = json_message
        else:
            json_dict = json.loads(json_message)

        self = cls(
            sampling_interval=json_dict['sampling_interval'],
            sample_size=json_dict['sample_size']
        )

        for name, sampler in json_dict['sample_storage'].items():
            mode = sampler['mode']
            new_sampler = self.register_sampler(name=name, mode=mode)
            new_sampler['index'].update(sampler['index'])

            for ticker, data in sampler['storage'].items():
                if ticker in new_sampler:
                    new_sampler['storage'][ticker].extend(data)
                else:
                    new_sampler['storage'][ticker] = deque(data, maxlen=self.sample_size)

        return self

    def clear(self):
        """
        Clears all stored data.
        """
        for name, sample_storage in self.sample_storage.items():
            for ticker, dq in sample_storage['storage'].items():
                dq.clear()

            self.sample_storage[name]['index'].clear()

        # using this code will require the sampler to be registered again.
        self.sample_storage.clear()

    def loc_obs(self, name: str, ticker: str, index: int | slice = None) -> float | list[float]:
        sampler = self.get_sampler(name=name)
        observation = sampler.get(ticker, [])

        if index is None:
            return list(observation)
        else:
            return list(observation)[index]

    def active_obs(self, name: str) -> dict[str, float]:
        sampler = self.get_sampler(name=name)
        last_obs = {}

        for ticker, observation in sampler.items():
            if observation:
                last_obs[ticker] = observation[-1]

        return last_obs
